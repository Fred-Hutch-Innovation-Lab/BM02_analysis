---
title: 'BM02 Clustering'
author: |
  | FHIL
  | Derrik Gratz
date: '`r Sys.Date()`'
output: 
  rmdformats::robobook:
    fig_width: 9
    toc_depth: 3
    css: "../config/robobook.css"
---

```{r, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = FALSE,
                      fig.width = 8, fig.height = 6,
                      cache=FALSE, cache.lazy = FALSE) 
```

This report is intended as an in-depth look at the decision points, intermediate data, and possible points of interest. 
It does not represent a final state of the data, and not every figure here is intended to be used for publication. 
Aesthetics and image quality can be improved for final versions of images.

# Natural clustering {.tabset}

Clustering resolution for each sample was selected by optomizing for the silhouette score for a span of resolution values that
produced between 5 and 20 clusters.The Louvian algorithm implemented by Seurat was used for clustering.

```{r, results='asis'}
out <- NULL
for (kit in unique(metadata$Kit)) {
  chunktext <- '\n## {{kit}} {.unlist}\n'
  out = c(out, knit_expand(text = chunktext))
      chunktext <- '
      \n```{r, fig.width=12, fig.height=10}\n
      grid.arrange(grobs=figures$Sample_level_umaps[["{{kit}}"]], nrow=2, ncol=2)
      \n```\n
      '
      out = c(out, knit_expand(text = chunktext))
}

cat(knit_child(text = out, quiet = TRUE), sep = '\n')
```

# Gene signatures {.tabset}

Celltype gene markers from literature. **If you have more, please let me know so we can expand the database**. 

```{r, results='asis'}
out <- NULL
for (kit in unique(metadata$Kit)) {
  chunktext <- '\n## {{kit}} {.tabset .unlist}\n'
  out = c(out, knit_expand(text = chunktext))
  for (sample in metadata$Sample[metadata$Kit == kit]) {
    ind <- metadata$Individual[metadata$Sample==sample]
    rep <- metadata$Replicate[metadata$Sample==sample]
    chunktext <- '\n### {{ind}}{{rep}} {.unlist}
    \n```{r, fig.width=40, fig.height=11}\n
    figures$marker_dotplots[[paste0("{{sample}}")]]
    \n```\n
    '
    out = c(out, knit_expand(text = chunktext))
  }
}

cat(knit_child(text = out, quiet = TRUE), sep = '\n')
```

# Reference mapping

Expression matrices from published annotated datasets are used to predict celltype labels in our data. [SingleR](https://www.nature.com/articles/s41590-018-0276-y) is used as the prediction algorithm with data
from the [celldex](https://github.com/SingleR-inc/celldex) collection. The following datasets were used:

- Human primary cell atlas [Mabbott et al. 2013](https://doi.org/10.1186/1471-2164-14-632)
- Sorted hematopoietic cells [Novershtern et al. 2011](https://doi.org/10.1016/j.cell.2011.01.004)

## Novershtern {.tabset}

```{r, results='asis'}
out <- NULL
for (kit in unique(metadata$Kit)) {
  chunktext <- '\n### {{kit}} {.tabset .unlist}\n'
  out = c(out, knit_expand(text = chunktext))
  for (sample in metadata$Sample[metadata$Kit == kit]) {
    ind <- metadata$Individual[metadata$Sample==sample]
    rep <- metadata$Replicate[metadata$Sample==sample]
    chunktext <- '\n#### {{ind}}{{rep}} {.unlist}
      \n```{r, fig.width=18, fig.height=5}\n
      grid.arrange(grobs=figures[["annotation_overlays_nove"]][["{{kit}}"]][["{{sample}}"]], nrow=1)
      nove_annotations[["{{sample}}"]] |>
          janitor::adorn_rounding(digits = 2) |>
          knitr::kable(col.names = c("Cluster", "Primary annotation", "% primary annotation", "Primary annotation median score",
                                               "Secondary annotation", "% secondary annotation", "Second annotation median score"))
      \n```\n
      '
      out = c(out, knit_expand(text = chunktext))
  }
}


cat(knit_child(text = out, quiet = TRUE), sep = '\n')
```

## Human primary cell atlas {.tabset}

```{r, results='asis'}
out <- NULL
for (kit in unique(metadata$Kit)) {
  chunktext <- '\n### {{kit}} {.tabset .unlist}\n'
  out = c(out, knit_expand(text = chunktext))
  for (sample in metadata$Sample[metadata$Kit == kit]) {
    ind <- metadata$Individual[metadata$Sample==sample]
    rep <- metadata$Replicate[metadata$Sample==sample]
    chunktext <- '\n#### {{ind}}{{rep}} {.unlist}
      \n```{r, fig.width=18, fig.height=5}\n
      grid.arrange(grobs=figures[["annotation_overlays_hpca"]][["{{kit}}"]][["{{sample}}"]], nrow=1)
      hpca_annotations[["{{sample}}"]] |>
          janitor::adorn_rounding(digits = 2) |>
          knitr::kable(col.names = c("Cluster", "Primary annotation", "% primary annotation", "Primary annotation median score",
                                               "Secondary annotation", "% secondary annotation", "Second annotation median score"))
      \n```\n
      '
      out = c(out, knit_expand(text = chunktext))
  }
}

cat(knit_child(text = out, quiet = TRUE), sep = '\n')
```

# Final annotations {.tabset}

My first pass at cell annotation, manually aggregating calls from the reference sets and marker genes.

**This will likely not be the final annotations, and should be reviewed more carefully.**

```{r, results='asis'}
out <- NULL
for (kit in unique(metadata$Kit)) {
  chunktext <- '\n## {{kit}} {.tabset .unlist}\n'
  out = c(out, knit_expand(text = chunktext))
  for (sample in metadata$Sample[metadata$Kit == kit]) {
    ind <- metadata$Individual[metadata$Sample==sample]
    rep <- metadata$Replicate[metadata$Sample==sample]
    chunktext <- '\n### {{ind}}{{rep}} {.unlist}
      \n```{r, fig.width=13, fig.height=5}\n
      grid.arrange(
        DimPlot(objs[["{{sample}}"]], group.by = "annotations", raster = TRUE, raster.dpi = c(512, 512), label=TRUE),
        DimPlot(objs[["{{sample}}"]], group.by = "cell_labels", raster = TRUE, raster.dpi = c(512, 512), label=TRUE),
        nrow=1
      )
      objs[["{{sample}}"]]@meta.data$cell_labels |> 
        tabyl() |> 
        arrange(desc(n)) |>
        adorn_rounding(digits=2) |>
        knitr::kable(col.names=c("Cell label", "Count", "Percent"))
      \n```\n
      '
      out = c(out, knit_expand(text = chunktext))
  }
}
cat(knit_child(text = out, quiet = TRUE), sep = '\n')
```
